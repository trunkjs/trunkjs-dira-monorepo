import { describe, it, expect } from 'bun:test';
import type { ExtractedRoute } from './extracted-route';
import { generateClientCode } from './generate-client-code';

function makeRoute(overrides: Partial<ExtractedRoute> = {}): ExtractedRoute {
  return {
    controllerName: 'items',
    handlerName: 'getItem',
    fullRoute: '/items/:id',
    httpMethods: ['GET'],
    bodyType: null,
    queryType: null,
    returnType: '{ id: string }',
    pathParams: ['id'],
    ...overrides,
  };
}

describe('generateClientCode', () => {
  it('should include the generated header comment', () => {
    const code = generateClientCode([]);
    expect(code).toContain('Generated by @dira/codegen');
  });

  it('should export TypedResponse interface', () => {
    const code = generateClientCode([]);
    expect(code).toContain(
      'export interface TypedResponse<T> extends Response',
    );
    expect(code).toContain('json(): Promise<T>');
  });

  it('should export createClient function with optional ClientOptions', () => {
    const code = generateClientCode([]);
    expect(code).toContain(
      'export function createClient(baseUrl: string, options?: ClientOptions): DiraClient',
    );
    expect(code).toContain('export interface ClientOptions');
    expect(code).toContain('fetch?: typeof fetch');
  });

  it('should generate handler with $method', () => {
    const code = generateClientCode([makeRoute()]);
    expect(code).toContain('$get');
    expect(code).not.toContain('$post');
  });

  it('should generate all default methods when httpMethods is undefined', () => {
    const code = generateClientCode([makeRoute({ httpMethods: undefined })]);
    expect(code).toContain('$get');
    expect(code).toContain('$post');
    expect(code).toContain('$put');
    expect(code).toContain('$patch');
    expect(code).toContain('$delete');
  });

  it('should make options required when path params exist', () => {
    const code = generateClientCode([makeRoute()]);
    expect(code).toContain('$get(options:');
    expect(code).toContain('params: { id: string }');
  });

  it('should make options optional when no params exist', () => {
    const code = generateClientCode([
      makeRoute({ fullRoute: '/items', pathParams: [] }),
    ]);
    expect(code).toContain('$get(options?:');
  });

  it('should include body type in options', () => {
    const code = generateClientCode([
      makeRoute({ bodyType: '{ name: string }' }),
    ]);
    expect(code).toContain('body: { name: string }');
  });

  it('should include query type in options', () => {
    const code = generateClientCode([
      makeRoute({ queryType: '{ q: string }' }),
    ]);
    expect(code).toContain('query: { q: string }');
  });

  it('should include return type in TypedResponse', () => {
    const code = generateClientCode([makeRoute()]);
    expect(code).toContain('Promise<TypedResponse<{ id: string }>>');
  });

  it('should group handlers under controller name in interface', () => {
    const code = generateClientCode([
      makeRoute({ controllerName: 'items', handlerName: 'getItem' }),
      makeRoute({
        controllerName: 'items',
        handlerName: 'listItems',
        fullRoute: '/items',
        pathParams: [],
      }),
    ]);
    // items should appear once in the interface (implementation uses Proxy)
    const matches = code.match(/items: \{/g);
    expect(matches?.length).toBe(1);
    // Both handlers should be in the interface
    expect(code).toContain('getItem:');
    expect(code).toContain('listItems:');
  });

  it('should nest controller names with dots', () => {
    const code = generateClientCode([
      makeRoute({
        controllerName: 'admin.users',
        fullRoute: '/admin/users',
        pathParams: [],
      }),
    ]);
    expect(code).toContain('admin: {');
    expect(code).toContain('users: {');
  });

  it('should include route path in routes map', () => {
    const code = generateClientCode([makeRoute()]);
    expect(code).toContain("path: '/items/:id'");
  });

  it('should include request runtime helper', () => {
    const code = generateClientCode([]);
    expect(code).toContain('function request(');
    expect(code).toContain('encodeURIComponent');
    expect(code).toContain('URLSearchParams');
  });

  it('should use Proxy-based implementation', () => {
    const code = generateClientCode([makeRoute()]);
    expect(code).toContain('new Proxy');
    expect(code).toContain('createProxy');
    expect(code).toContain('const routes:');
  });

  it('should expose $routes metadata on client interface', () => {
    const code = generateClientCode([makeRoute()]);
    expect(code).toContain('$routes: Record<string, RouteMetadata>');
    expect(code).toContain('export interface RouteMetadata');
    expect(code).toContain("if (prop === '$routes') return routes");
  });

  it('should expose $route metadata on each handler', () => {
    const code = generateClientCode([makeRoute()]);
    expect(code).toContain('$route: RouteMetadata;');
    expect(code).toContain(
      "if (prop === '$route') return routes[pathParts.join('.')]",
    );
  });

  it('should use default DiraClient name when clientName not provided', () => {
    const code = generateClientCode([]);
    expect(code).toContain('export interface DiraClient');
    expect(code).toContain('): DiraClient {');
  });

  it('should use custom client name when provided', () => {
    const code = generateClientCode([], { clientName: 'MyApiClient' });
    expect(code).toContain('export interface MyApiClient');
    expect(code).toContain('): MyApiClient {');
    expect(code).not.toContain('DiraClient');
  });

  it('should handle wildcard params (::key) separately from regular params (:key)', () => {
    const code = generateClientCode([
      makeRoute({
        fullRoute: '/files/::path',
        pathParams: ['path'],
      }),
    ]);
    // Should include check for wildcard params
    expect(code).toContain("if (url.includes('::' + key))");
    // Should encode each segment but preserve slashes for wildcards
    expect(code).toContain(
      "value.split('/').map(s => encodeURIComponent(s)).join('/')",
    );
    // Should replace ::key for wildcards
    expect(code).toContain("url.replace('::' + key, encoded)");
    // Should still handle regular :key params
    expect(code).toContain('url.replace(`:${key}`, encodeURIComponent(value))');
  });

  it('should handle mixed regular and wildcard params in the same route', () => {
    const code = generateClientCode([
      makeRoute({
        fullRoute: '/repos/:owner/:repo/files/::path',
        pathParams: ['owner', 'repo', 'path'],
      }),
    ]);
    // Should require all params
    expect(code).toContain(
      'params: { owner: string; repo: string; path: string }',
    );
    // Route should be in the routes map
    expect(code).toContain("path: '/repos/:owner/:repo/files/::path'");
  });

  it('should convert hyphenated controller names to valid identifiers', () => {
    const code = generateClientCode([
      makeRoute({
        controllerName: 'user-management',
        handlerName: 'getUsers',
        fullRoute: '/user-management/users',
        pathParams: [],
      }),
    ]);
    // Should convert user-management to userManagement
    expect(code).toContain('userManagement: {');
    expect(code).not.toContain('user-management: {');
  });

  it('should convert hyphenated handler names to valid identifiers', () => {
    const code = generateClientCode([
      makeRoute({
        controllerName: 'users',
        handlerName: 'get-by-id',
        fullRoute: '/users/:id',
        pathParams: ['id'],
      }),
    ]);
    // Should convert get-by-id to getById
    expect(code).toContain('getById: {');
    expect(code).not.toContain('get-by-id: {');
  });

  it('should convert hyphenated nested controller names to valid identifiers', () => {
    const code = generateClientCode([
      makeRoute({
        controllerName: 'admin-panel.user-management',
        handlerName: 'list-users',
        fullRoute: '/admin/users',
        pathParams: [],
      }),
    ]);
    // Should convert each segment to valid identifiers in the interface
    expect(code).toContain('adminPanel: {');
    expect(code).toContain('userManagement: {');
    expect(code).toContain('listUsers: {');
    // Should NOT have hyphenated names as unquoted property identifiers
    expect(code).not.toContain('admin-panel: {');
    expect(code).not.toContain('user-management: {');
    expect(code).not.toContain('list-users: {');
    // But routes map should preserve original names as string keys (for runtime lookup)
    expect(code).toContain("'admin-panel.user-management.list-users'");
  });
});
