import { describe, it, expect } from 'bun:test';
import type { ExtractedRoute } from './extracted-route';
import { generateClientCode } from './generate-client-code';

function makeRoute(overrides: Partial<ExtractedRoute> = {}): ExtractedRoute {
  return {
    controllerName: 'items',
    handlerName: 'getItem',
    fullRoute: '/items/:id',
    httpMethods: ['GET'],
    bodyType: null,
    queryType: null,
    returnType: '{ id: string }',
    pathParams: ['id'],
    ...overrides,
  };
}

describe('generateClientCode', () => {
  it('should include the generated header comment', () => {
    const code = generateClientCode([]);
    expect(code).toContain('Generated by @dira/codegen');
  });

  it('should export TypedResponse interface', () => {
    const code = generateClientCode([]);
    expect(code).toContain(
      'export interface TypedResponse<T> extends Response',
    );
    expect(code).toContain('json(): Promise<T>');
  });

  it('should export createClient function with optional ClientOptions', () => {
    const code = generateClientCode([]);
    expect(code).toContain(
      'export function createClient(baseUrl: string, options?: ClientOptions): DiraClient',
    );
    expect(code).toContain('export interface ClientOptions');
    expect(code).toContain('fetch?: typeof fetch');
  });

  it('should generate handler with $method', () => {
    const code = generateClientCode([makeRoute()]);
    expect(code).toContain('$get');
    expect(code).not.toContain('$post');
  });

  it('should generate all default methods when httpMethods is undefined', () => {
    const code = generateClientCode([makeRoute({ httpMethods: undefined })]);
    expect(code).toContain('$get');
    expect(code).toContain('$post');
    expect(code).toContain('$put');
    expect(code).toContain('$patch');
    expect(code).toContain('$delete');
  });

  it('should make options required when path params exist', () => {
    const code = generateClientCode([makeRoute()]);
    expect(code).toContain('$get(options:');
    expect(code).toContain('params: { id: string }');
  });

  it('should make options optional when no params exist', () => {
    const code = generateClientCode([
      makeRoute({ fullRoute: '/items', pathParams: [] }),
    ]);
    expect(code).toContain('$get(options?:');
  });

  it('should include body type in options', () => {
    const code = generateClientCode([
      makeRoute({ bodyType: '{ name: string }' }),
    ]);
    expect(code).toContain('body: { name: string }');
  });

  it('should include query type in options', () => {
    const code = generateClientCode([
      makeRoute({ queryType: '{ q: string }' }),
    ]);
    expect(code).toContain('query: { q: string }');
  });

  it('should include return type in TypedResponse', () => {
    const code = generateClientCode([makeRoute()]);
    expect(code).toContain('Promise<TypedResponse<{ id: string }>>');
  });

  it('should group handlers under controller name in interface', () => {
    const code = generateClientCode([
      makeRoute({ controllerName: 'items', handlerName: 'getItem' }),
      makeRoute({
        controllerName: 'items',
        handlerName: 'listItems',
        fullRoute: '/items',
        pathParams: [],
      }),
    ]);
    // items should appear once in the interface (implementation uses Proxy)
    const matches = code.match(/items: \{/g);
    expect(matches?.length).toBe(1);
    // Both handlers should be in the interface
    expect(code).toContain('getItem:');
    expect(code).toContain('listItems:');
  });

  it('should nest controller names with dots', () => {
    const code = generateClientCode([
      makeRoute({
        controllerName: 'admin.users',
        fullRoute: '/admin/users',
        pathParams: [],
      }),
    ]);
    expect(code).toContain('admin: {');
    expect(code).toContain('users: {');
  });

  it('should include route path in routes map', () => {
    const code = generateClientCode([makeRoute()]);
    expect(code).toContain("path: '/items/:id'");
  });

  it('should include request runtime helper', () => {
    const code = generateClientCode([]);
    expect(code).toContain('function request(');
    expect(code).toContain('encodeURIComponent');
    expect(code).toContain('URLSearchParams');
  });

  it('should use Proxy-based implementation', () => {
    const code = generateClientCode([makeRoute()]);
    expect(code).toContain('new Proxy');
    expect(code).toContain('createProxy');
    expect(code).toContain('const routes:');
  });

  it('should use default DiraClient name when clientName not provided', () => {
    const code = generateClientCode([]);
    expect(code).toContain('export interface DiraClient');
    expect(code).toContain('): DiraClient {');
  });

  it('should use custom client name when provided', () => {
    const code = generateClientCode([], { clientName: 'MyApiClient' });
    expect(code).toContain('export interface MyApiClient');
    expect(code).toContain('): MyApiClient {');
    expect(code).not.toContain('DiraClient');
  });
});
