import type { ExtractedRoute } from './extracted-route';

const DEFAULT_METHODS = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'] as const;
const DEFAULT_CLIENT_NAME = 'DiraClient';

export interface GenerateClientCodeOptions {
  /** Name for the generated client interface (e.g., "MyApiClient"). Defaults to "DiraClient". */
  clientName?: string;
}

/**
 * Generates a self-contained TypeScript client file from extracted route metadata.
 * The output includes runtime helpers, typed interfaces, and a `createClient` factory.
 * Uses a Proxy-based implementation to avoid duplicating the nested structure.
 */
export function generateClientCode(
  routes: ExtractedRoute[],
  options?: GenerateClientCodeOptions,
): string {
  const clientName = options?.clientName || DEFAULT_CLIENT_NAME;
  const lines: string[] = [];

  // Runtime types and helpers
  lines.push(`// Generated by @dira/codegen â€” do not edit manually.`);
  lines.push('');
  lines.push(`export interface TypedResponse<T> extends Response {`);
  lines.push(`  json(): Promise<T>;`);
  lines.push(`}`);
  lines.push('');
  lines.push(`export interface ClientOptions {`);
  lines.push(`  fetch?: typeof fetch;`);
  lines.push(`}`);
  lines.push('');
  lines.push(`export interface RouteMetadata {`);
  lines.push(`  path: string;`);
  lines.push(`  methods: string[];`);
  lines.push(`}`);
  lines.push('');
  lines.push(
    `interface RequestOptions<TBody = never, TQuery = never, TParams = never> {`,
  );
  lines.push(`  body?: TBody;`);
  lines.push(`  query?: TQuery;`);
  lines.push(`  params?: TParams;`);
  lines.push(`  headers?: HeadersInit;`);
  lines.push(`}`);
  lines.push('');

  // Internal request function
  lines.push(`function request(`);
  lines.push(`  fetchFn: typeof fetch,`);
  lines.push(`  baseUrl: string,`);
  lines.push(`  method: string,`);
  lines.push(`  path: string,`);
  lines.push(`  options?: RequestOptions<unknown, unknown, unknown>,`);
  lines.push(`): Promise<TypedResponse<unknown>> {`);
  lines.push(`  let url = path;`);
  lines.push(`  if (options?.params) {`);
  lines.push(
    `    for (const [key, value] of Object.entries(options.params as Record<string, string>)) {`,
  );
  lines.push(
    `      url = url.replace(\`:$\{key}\`, encodeURIComponent(value));`,
  );
  lines.push(`    }`);
  lines.push(`  }`);
  lines.push(`  let fullUrl = baseUrl + url;`);
  lines.push(`  if (options?.query) {`);
  lines.push(`    const searchParams = new URLSearchParams();`);
  lines.push(
    `    for (const [key, value] of Object.entries(options.query as Record<string, string | string[]>)) {`,
  );
  lines.push(`      if (Array.isArray(value)) {`);
  lines.push(`        for (const v of value) searchParams.append(key, v);`);
  lines.push(`      } else if (value !== undefined) {`);
  lines.push(`        searchParams.append(key, value);`);
  lines.push(`      }`);
  lines.push(`    }`);
  lines.push(`    const qs = searchParams.toString();`);
  lines.push(`    if (qs) fullUrl += '?' + qs;`);
  lines.push(`  }`);
  lines.push(
    `  const init: RequestInit = { method, headers: options?.headers };`,
  );
  lines.push(`  if (options?.body !== undefined) {`);
  lines.push(`    init.body = JSON.stringify(options.body);`);
  lines.push(`    init.headers = new Headers(init.headers);`);
  lines.push(
    `    (init.headers as Headers).set('Content-Type', 'application/json');`,
  );
  lines.push(`  }`);
  lines.push(
    `  return fetchFn(fullUrl, init) as Promise<TypedResponse<unknown>>;`,
  );
  lines.push(`}`);
  lines.push('');

  // Generate route map
  lines.push(`const routes: Record<string, RouteMetadata> = {`);
  for (const route of routes) {
    const key = `${route.controllerName}.${route.handlerName}`;
    const methods = route.httpMethods ?? [...DEFAULT_METHODS];
    lines.push(
      `  '${key}': { path: '${route.fullRoute}', methods: ${JSON.stringify(methods)} },`,
    );
  }
  lines.push(`};`);
  lines.push('');

  // Group routes by controller for interface generation
  const byController = new Map<string, ExtractedRoute[]>();
  for (const route of routes) {
    const existing = byController.get(route.controllerName) ?? [];
    existing.push(route);
    byController.set(route.controllerName, existing);
  }

  // Generate client type
  lines.push(`export interface ${clientName} {`);
  lines.push(`  /** Route metadata for all endpoints */`);
  lines.push(`  $routes: Record<string, RouteMetadata>;`);
  for (const [controllerName, controllerRoutes] of byController) {
    const segments = controllerName.includes('.')
      ? controllerName.split('.')
      : [controllerName];
    lines.push(...generateNestedInterface(segments, controllerRoutes, 1));
  }
  lines.push(`}`);
  lines.push('');

  // Generate Proxy-based createClient
  lines.push(
    `export function createClient(baseUrl: string, options?: ClientOptions): ${clientName} {`,
  );
  lines.push(`  const fetchFn = options?.fetch ?? fetch;`);
  lines.push('');
  lines.push(`  function createProxy(pathParts: string[]): unknown {`);
  lines.push(`    return new Proxy(() => {}, {`);
  lines.push(`      get(_, prop: string) {`);
  lines.push(`        if (prop === '$routes') return routes;`);
  lines.push(
    `        if (prop === '$route') return routes[pathParts.join('.')];`,
  );
  lines.push(`        if (prop.startsWith('$')) {`);
  lines.push(`          const method = prop.slice(1).toUpperCase();`);
  lines.push(`          const routeKey = pathParts.join('.');`);
  lines.push(`          const route = routes[routeKey];`);
  lines.push(`          if (!route) return undefined;`);
  lines.push(
    `          return (opts?: unknown) => request(fetchFn, baseUrl, method, route.path, opts as any);`,
  );
  lines.push(`        }`);
  lines.push(`        return createProxy([...pathParts, prop]);`);
  lines.push(`      },`);
  lines.push(`    });`);
  lines.push(`  }`);
  lines.push('');
  lines.push(`  return createProxy([]) as ${clientName};`);
  lines.push(`}`);

  return lines.join('\n') + '\n';
}

function generateNestedInterface(
  segments: string[],
  routes: ExtractedRoute[],
  indent: number,
): string[] {
  const pad = '  '.repeat(indent);
  const lines: string[] = [];

  if (segments.length === 1) {
    lines.push(`${pad}${segments[0]}: {`);
    for (const route of routes) {
      lines.push(...generateHandlerType(route, indent + 1));
    }
    lines.push(`${pad}};`);
  } else {
    lines.push(`${pad}${segments[0]}: {`);
    lines.push(
      ...generateNestedInterface(segments.slice(1), routes, indent + 1),
    );
    lines.push(`${pad}};`);
  }

  return lines;
}

function generateHandlerType(route: ExtractedRoute, indent: number): string[] {
  const pad = '  '.repeat(indent);
  const lines: string[] = [];
  const methods = route.httpMethods ?? [...DEFAULT_METHODS];

  lines.push(`${pad}${route.handlerName}: {`);
  lines.push(`${pad}  $route: RouteMetadata;`);
  for (const method of methods) {
    const m = method.toLowerCase();
    const optionsType = buildOptionsType(route);
    lines.push(
      `${pad}  $${m}(options${optionsType.required ? '' : '?'}: ${optionsType.type}): Promise<TypedResponse<${route.returnType}>>;`,
    );
  }
  lines.push(`${pad}};`);

  return lines;
}

interface OptionsTypeInfo {
  type: string;
  required: boolean;
}

function buildOptionsType(route: ExtractedRoute): OptionsTypeInfo {
  const parts: string[] = [];
  let required = false;

  if (route.bodyType) {
    parts.push(`body: ${route.bodyType}`);
  }
  if (route.queryType) {
    parts.push(`query: ${route.queryType}`);
  }
  if (route.pathParams.length > 0) {
    const paramObj = route.pathParams.map((p) => `${p}: string`).join('; ');
    parts.push(`params: { ${paramObj} }`);
    required = true;
  }

  parts.push('headers?: HeadersInit');

  return {
    type: `{ ${parts.join('; ')} }`,
    required,
  };
}
