import type { ExtractedRoute } from './extracted-route';

const DEFAULT_METHODS = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'] as const;

/**
 * Generates a self-contained TypeScript client file from extracted route metadata.
 * The output includes runtime helpers, typed interfaces, and a `createClient` factory.
 */
export function generateClientCode(routes: ExtractedRoute[]): string {
  const lines: string[] = [];

  // Runtime types and helpers
  lines.push(`// Generated by @dira/codegen â€” do not edit manually.`);
  lines.push('');
  lines.push(`export interface TypedResponse<T> extends Response {`);
  lines.push(`  json(): Promise<T>;`);
  lines.push(`}`);
  lines.push('');
  lines.push(`export interface ClientOptions {`);
  lines.push(`  fetch?: typeof fetch;`);
  lines.push(`}`);
  lines.push('');
  lines.push(
    `interface RequestOptions<TBody = never, TQuery = never, TParams = never> {`,
  );
  lines.push(`  body?: TBody;`);
  lines.push(`  query?: TQuery;`);
  lines.push(`  params?: TParams;`);
  lines.push(`  headers?: HeadersInit;`);
  lines.push(`}`);
  lines.push('');

  // Internal request function
  lines.push(`function request(`);
  lines.push(`  fetchFn: typeof fetch,`);
  lines.push(`  baseUrl: string,`);
  lines.push(`  method: string,`);
  lines.push(`  path: string,`);
  lines.push(`  options?: RequestOptions<unknown, unknown, unknown>,`);
  lines.push(`): Promise<TypedResponse<unknown>> {`);
  lines.push(`  let url = path;`);
  lines.push(`  if (options?.params) {`);
  lines.push(
    `    for (const [key, value] of Object.entries(options.params as Record<string, string>)) {`,
  );
  lines.push(
    `      url = url.replace(\`:$\{key}\`, encodeURIComponent(value));`,
  );
  lines.push(`    }`);
  lines.push(`  }`);
  lines.push(`  let fullUrl = baseUrl + url;`);
  lines.push(`  if (options?.query) {`);
  lines.push(`    const searchParams = new URLSearchParams();`);
  lines.push(
    `    for (const [key, value] of Object.entries(options.query as Record<string, string | string[]>)) {`,
  );
  lines.push(`      if (Array.isArray(value)) {`);
  lines.push(`        for (const v of value) searchParams.append(key, v);`);
  lines.push(`      } else if (value !== undefined) {`);
  lines.push(`        searchParams.append(key, value);`);
  lines.push(`      }`);
  lines.push(`    }`);
  lines.push(`    const qs = searchParams.toString();`);
  lines.push(`    if (qs) fullUrl += '?' + qs;`);
  lines.push(`  }`);
  lines.push(
    `  const init: RequestInit = { method, headers: options?.headers };`,
  );
  lines.push(`  if (options?.body !== undefined) {`);
  lines.push(`    init.body = JSON.stringify(options.body);`);
  lines.push(`    init.headers = new Headers(init.headers);`);
  lines.push(
    `    (init.headers as Headers).set('Content-Type', 'application/json');`,
  );
  lines.push(`  }`);
  lines.push(
    `  return fetchFn(fullUrl, init) as Promise<TypedResponse<unknown>>;`,
  );
  lines.push(`}`);
  lines.push('');

  // Group routes by controller
  const byController = new Map<string, ExtractedRoute[]>();
  for (const route of routes) {
    const existing = byController.get(route.controllerName) ?? [];
    existing.push(route);
    byController.set(route.controllerName, existing);
  }

  // Generate client type
  lines.push(`export interface DiraClient {`);
  for (const [controllerName, controllerRoutes] of byController) {
    const segments = controllerName.includes('.')
      ? controllerName.split('.')
      : [controllerName];
    lines.push(...generateNestedInterface(segments, controllerRoutes, 1));
  }
  lines.push(`}`);
  lines.push('');

  // Generate createClient
  lines.push(
    `export function createClient(baseUrl: string, options?: ClientOptions): DiraClient {`,
  );
  lines.push(`  const fetchFn = options?.fetch ?? fetch;`);
  lines.push(`  return {`);
  for (const [controllerName, controllerRoutes] of byController) {
    const segments = controllerName.includes('.')
      ? controllerName.split('.')
      : [controllerName];
    lines.push(...generateNestedObject(segments, controllerRoutes, 2));
  }
  lines.push(`  };`);
  lines.push(`}`);

  return lines.join('\n') + '\n';
}

function generateNestedInterface(
  segments: string[],
  routes: ExtractedRoute[],
  indent: number,
): string[] {
  const pad = '  '.repeat(indent);
  const lines: string[] = [];

  if (segments.length === 1) {
    lines.push(`${pad}${segments[0]}: {`);
    for (const route of routes) {
      lines.push(...generateHandlerType(route, indent + 1));
    }
    lines.push(`${pad}};`);
  } else {
    lines.push(`${pad}${segments[0]}: {`);
    lines.push(
      ...generateNestedInterface(segments.slice(1), routes, indent + 1),
    );
    lines.push(`${pad}};`);
  }

  return lines;
}

function generateHandlerType(route: ExtractedRoute, indent: number): string[] {
  const pad = '  '.repeat(indent);
  const lines: string[] = [];
  const methods = route.httpMethods ?? [...DEFAULT_METHODS];

  lines.push(`${pad}${route.handlerName}: {`);
  for (const method of methods) {
    const m = method.toLowerCase();
    const optionsType = buildOptionsType(route);
    lines.push(
      `${pad}  $${m}(options${optionsType.required ? '' : '?'}: ${optionsType.type}): Promise<TypedResponse<${route.returnType}>>;`,
    );
  }
  lines.push(`${pad}};`);

  return lines;
}

function generateNestedObject(
  segments: string[],
  routes: ExtractedRoute[],
  indent: number,
): string[] {
  const pad = '  '.repeat(indent);
  const lines: string[] = [];

  if (segments.length === 1) {
    lines.push(`${pad}${segments[0]}: {`);
    for (const route of routes) {
      lines.push(...generateHandlerImpl(route, indent + 1));
    }
    lines.push(`${pad}},`);
  } else {
    lines.push(`${pad}${segments[0]}: {`);
    lines.push(...generateNestedObject(segments.slice(1), routes, indent + 1));
    lines.push(`${pad}},`);
  }

  return lines;
}

function generateHandlerImpl(route: ExtractedRoute, indent: number): string[] {
  const pad = '  '.repeat(indent);
  const lines: string[] = [];
  const methods = route.httpMethods ?? [...DEFAULT_METHODS];

  lines.push(`${pad}${route.handlerName}: {`);
  for (const method of methods) {
    const m = method.toLowerCase();
    lines.push(
      `${pad}  $${m}: (options?: any) => request(fetchFn, baseUrl, '${method}', '${route.fullRoute}', options) as any,`,
    );
  }
  lines.push(`${pad}},`);

  return lines;
}

interface OptionsTypeInfo {
  type: string;
  required: boolean;
}

function buildOptionsType(route: ExtractedRoute): OptionsTypeInfo {
  const parts: string[] = [];
  let required = false;

  if (route.bodyType) {
    parts.push(`body: ${route.bodyType}`);
  }
  if (route.queryType) {
    parts.push(`query: ${route.queryType}`);
  }
  if (route.pathParams.length > 0) {
    const paramObj = route.pathParams.map((p) => `${p}: string`).join('; ');
    parts.push(`params: { ${paramObj} }`);
    required = true;
  }

  parts.push('headers?: HeadersInit');

  return {
    type: `{ ${parts.join('; ')} }`,
    required,
  };
}
