import ts from 'typescript';
import type { ExtractedRoute } from './extracted-route';
import type { TypeReference, TypeImportInfo } from './type-reference';
import { resolveImportPath } from './resolve-import-path';
import { toCamelCase } from './name-utils';

const DEFAULT_METHODS = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'] as const;
const DEFAULT_CLIENT_NAME = 'DiraClient';

export interface GenerateClientCodeOptions {
  /** Name for the generated client interface (e.g., "MyApiClient"). Defaults to "DiraClient". */
  clientName?: string;
  /** When true, import named types instead of inlining their structure. */
  useTypeImports?: boolean;
  /** Output file path (required for relative path calculation when useTypeImports is true). */
  outputFilePath?: string;
  /** Compiler options from tsconfig (for path alias resolution). */
  compilerOptions?: ts.CompilerOptions;
  /** Base directory for resolving paths (typically the tsconfig directory). */
  baseDir?: string;
}

/** Collected import info grouped by source file */
interface ImportCollection {
  /** Map from source file path to set of type names */
  byFile: Map<string, Set<string>>;
}

/**
 * Generates a self-contained TypeScript client file from extracted route metadata.
 * The output includes runtime helpers, typed interfaces, and a `createClient` factory.
 * Uses a Proxy-based implementation to avoid duplicating the nested structure.
 */
export function generateClientCode(
  routes: ExtractedRoute[],
  options?: GenerateClientCodeOptions,
): string {
  const clientName = options?.clientName || DEFAULT_CLIENT_NAME;
  const useTypeImports =
    options?.useTypeImports && options?.outputFilePath !== undefined;
  const lines: string[] = [];

  // Collect and generate type imports if enabled
  let importedTypes = new Set<string>();
  if (useTypeImports) {
    const imports = collectTypeImports(routes);
    importedTypes = generateImportStatements(
      imports,
      options.outputFilePath!,
      options.compilerOptions,
      options.baseDir,
      lines,
    );
  }

  // Runtime types and helpers
  lines.push(`// Generated by @dira/codegen â€” do not edit manually.`);
  lines.push('');
  lines.push(`export interface TypedResponse<T> extends Response {`);
  lines.push(`  json(): Promise<T>;`);
  lines.push(`}`);
  lines.push('');
  lines.push(`export interface ClientOptions {`);
  lines.push(`  fetch?: typeof fetch;`);
  lines.push(`}`);
  lines.push('');
  lines.push(`export interface RouteMetadata {`);
  lines.push(`  path: string;`);
  lines.push(`  methods: string[];`);
  lines.push(`}`);
  lines.push('');
  lines.push(
    `interface RequestOptions<TBody = never, TQuery = never, TParams = never> {`,
  );
  lines.push(`  body?: TBody;`);
  lines.push(`  query?: TQuery;`);
  lines.push(`  params?: TParams;`);
  lines.push(`  headers?: HeadersInit;`);
  lines.push(`}`);
  lines.push('');

  // Internal request function
  lines.push(`function request(`);
  lines.push(`  fetchFn: typeof fetch,`);
  lines.push(`  baseUrl: string,`);
  lines.push(`  method: string,`);
  lines.push(`  path: string,`);
  lines.push(`  options?: RequestOptions<unknown, unknown, unknown>,`);
  lines.push(`): Promise<TypedResponse<unknown>> {`);
  lines.push(`  let url = path;`);
  lines.push(`  if (options?.params) {`);
  lines.push(
    `    for (const [key, value] of Object.entries(options.params as Record<string, string>)) {`,
  );
  lines.push(
    `      // Handle wildcard params (::key) - encode each segment but preserve slashes`,
  );
  lines.push(`      if (url.includes('::' + key)) {`);
  lines.push(
    `        const encoded = value.split('/').map(s => encodeURIComponent(s)).join('/');`,
  );
  lines.push(`        url = url.replace('::' + key, encoded);`);
  lines.push(`      } else {`);
  lines.push(`        // Handle regular params (:key)`);
  lines.push(
    `        url = url.replace(\`:$\{key}\`, encodeURIComponent(value));`,
  );
  lines.push(`      }`);
  lines.push(`    }`);
  lines.push(`  }`);
  lines.push(`  let fullUrl = baseUrl + url;`);
  lines.push(`  if (options?.query) {`);
  lines.push(`    const searchParams = new URLSearchParams();`);
  lines.push(
    `    for (const [key, value] of Object.entries(options.query as Record<string, string | string[]>)) {`,
  );
  lines.push(`      if (Array.isArray(value)) {`);
  lines.push(`        for (const v of value) searchParams.append(key, v);`);
  lines.push(`      } else if (value !== undefined) {`);
  lines.push(`        searchParams.append(key, value);`);
  lines.push(`      }`);
  lines.push(`    }`);
  lines.push(`    const qs = searchParams.toString();`);
  lines.push(`    if (qs) fullUrl += '?' + qs;`);
  lines.push(`  }`);
  lines.push(
    `  const init: RequestInit = { method, headers: options?.headers };`,
  );
  lines.push(`  if (options?.body !== undefined) {`);
  lines.push(`    init.body = JSON.stringify(options.body);`);
  lines.push(`    init.headers = new Headers(init.headers);`);
  lines.push(
    `    (init.headers as Headers).set('Content-Type', 'application/json');`,
  );
  lines.push(`  }`);
  lines.push(
    `  return fetchFn(fullUrl, init) as Promise<TypedResponse<unknown>>;`,
  );
  lines.push(`}`);
  lines.push('');

  // Generate route map
  lines.push(`const routes: Record<string, RouteMetadata> = {`);
  for (const route of routes) {
    const key = `${route.controllerName}.${route.handlerName}`;
    const methods = route.httpMethods ?? [...DEFAULT_METHODS];
    lines.push(
      `  '${key}': { path: '${route.fullRoute}', methods: ${JSON.stringify(methods)} },`,
    );
  }
  lines.push(`};`);
  lines.push('');

  // Group routes by controller for interface generation
  const byController = new Map<string, ExtractedRoute[]>();
  for (const route of routes) {
    const existing = byController.get(route.controllerName) ?? [];
    existing.push(route);
    byController.set(route.controllerName, existing);
  }

  // Generate client type
  lines.push(`export interface ${clientName} {`);
  lines.push(`  /** Route metadata for all endpoints */`);
  lines.push(`  $routes: Record<string, RouteMetadata>;`);
  for (const [controllerName, controllerRoutes] of byController) {
    const segments = controllerName.includes('.')
      ? controllerName.split('.')
      : [controllerName];
    lines.push(
      ...generateNestedInterface(segments, controllerRoutes, 1, importedTypes),
    );
  }
  lines.push(`}`);
  lines.push('');

  // Generate Proxy-based createClient
  lines.push(
    `export function createClient(baseUrl: string, options?: ClientOptions): ${clientName} {`,
  );
  lines.push(`  const fetchFn = options?.fetch ?? fetch;`);
  lines.push('');
  lines.push(`  function createProxy(pathParts: string[]): unknown {`);
  lines.push(`    return new Proxy(() => {}, {`);
  lines.push(`      get(_, prop: string) {`);
  lines.push(`        if (prop === '$routes') return routes;`);
  lines.push(
    `        if (prop === '$route') return routes[pathParts.join('.')];`,
  );
  lines.push(`        if (prop.startsWith('$')) {`);
  lines.push(`          const method = prop.slice(1).toUpperCase();`);
  lines.push(`          const routeKey = pathParts.join('.');`);
  lines.push(`          const route = routes[routeKey];`);
  lines.push(`          if (!route) return undefined;`);
  lines.push(
    `          return (opts?: unknown) => request(fetchFn, baseUrl, method, route.path, opts as any);`,
  );
  lines.push(`        }`);
  lines.push(`        return createProxy([...pathParts, prop]);`);
  lines.push(`      },`);
  lines.push(`    });`);
  lines.push(`  }`);
  lines.push('');
  lines.push(`  return createProxy([]) as ${clientName};`);
  lines.push(`}`);

  return lines.join('\n') + '\n';
}

function generateNestedInterface(
  segments: string[],
  routes: ExtractedRoute[],
  indent: number,
  importedTypes: Set<string>,
): string[] {
  const pad = '  '.repeat(indent);
  const lines: string[] = [];

  const safeSegment = toCamelCase(segments[0]);

  if (segments.length === 1) {
    lines.push(`${pad}${safeSegment}: {`);
    for (const route of routes) {
      lines.push(...generateHandlerType(route, indent + 1, importedTypes));
    }
    lines.push(`${pad}};`);
  } else {
    lines.push(`${pad}${safeSegment}: {`);
    lines.push(
      ...generateNestedInterface(
        segments.slice(1),
        routes,
        indent + 1,
        importedTypes,
      ),
    );
    lines.push(`${pad}};`);
  }

  return lines;
}

function generateHandlerType(
  route: ExtractedRoute,
  indent: number,
  importedTypes: Set<string>,
): string[] {
  const pad = '  '.repeat(indent);
  const lines: string[] = [];
  const methods = route.httpMethods ?? [...DEFAULT_METHODS];

  // Resolve return type (use imported name or inline)
  const returnType = resolveTypeString(
    route.returnTypeRef,
    route.returnType,
    importedTypes,
  );

  const safeHandlerName = toCamelCase(route.handlerName);
  lines.push(`${pad}${safeHandlerName}: {`);
  lines.push(`${pad}  $route: RouteMetadata;`);
  for (const method of methods) {
    const m = method.toLowerCase();
    const optionsType = buildOptionsType(route, importedTypes);
    lines.push(
      `${pad}  $${m}(options${optionsType.required ? '' : '?'}: ${optionsType.type}): Promise<TypedResponse<${returnType}>>;`,
    );
  }
  lines.push(`${pad}};`);

  return lines;
}

interface OptionsTypeInfo {
  type: string;
  required: boolean;
}

function buildOptionsType(
  route: ExtractedRoute,
  importedTypes: Set<string>,
): OptionsTypeInfo {
  const parts: string[] = [];
  let required = false;

  if (route.bodyType) {
    const bodyType = resolveTypeString(
      route.bodyTypeRef,
      route.bodyType,
      importedTypes,
    );
    parts.push(`body: ${bodyType}`);
  }
  if (route.queryType) {
    const queryType = resolveTypeString(
      route.queryTypeRef,
      route.queryType,
      importedTypes,
    );
    parts.push(`query: ${queryType}`);
  }
  if (route.pathParams.length > 0) {
    const paramObj = route.pathParams.map((p) => `${p}: string`).join('; ');
    parts.push(`params: { ${paramObj} }`);
    required = true;
  }

  parts.push('headers?: HeadersInit');

  return {
    type: `{ ${parts.join('; ')} }`,
    required,
  };
}

/**
 * Resolves the type string to use in generated code.
 * Uses the imported type name if available and imported, otherwise falls back to inline.
 */
function resolveTypeString(
  typeRef: TypeReference | null | undefined,
  fallback: string,
  importedTypes: Set<string>,
): string {
  if (typeRef?.importInfo && importedTypes.has(typeRef.importInfo.typeName)) {
    return typeRef.importInfo.typeName;
  }
  return typeRef?.inlineType ?? fallback;
}

/**
 * Collects all importable types from extracted routes.
 */
function collectTypeImports(routes: ExtractedRoute[]): ImportCollection {
  const byFile = new Map<string, Set<string>>();

  function addImport(info: TypeImportInfo | null | undefined): void {
    if (!info) return;
    const existing = byFile.get(info.sourceFilePath) ?? new Set();
    existing.add(info.typeName);
    byFile.set(info.sourceFilePath, existing);
  }

  for (const route of routes) {
    addImport(route.bodyTypeRef?.importInfo);
    addImport(route.queryTypeRef?.importInfo);
    addImport(route.returnTypeRef?.importInfo);
  }

  return { byFile };
}

/**
 * Generates import statements and returns the set of imported type names.
 */
function generateImportStatements(
  imports: ImportCollection,
  outputFilePath: string,
  compilerOptions: ts.CompilerOptions | undefined,
  baseDir: string | undefined,
  lines: string[],
): Set<string> {
  const importedTypes = new Set<string>();

  if (imports.byFile.size === 0) {
    return importedTypes;
  }

  for (const [sourceFile, typeNames] of imports.byFile) {
    const importPath = resolveImportPath(
      sourceFile,
      outputFilePath,
      compilerOptions,
      baseDir,
    );
    const names = Array.from(typeNames).sort();
    lines.push(`import type { ${names.join(', ')} } from '${importPath}';`);
    for (const name of names) {
      importedTypes.add(name);
    }
  }

  lines.push('');

  return importedTypes;
}
