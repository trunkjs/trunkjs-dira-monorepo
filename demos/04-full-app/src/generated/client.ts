import type { Customer, UpdateCustomerInput } from '../domain/customer';
import type { AuthToken } from '../domain/user';

// Generated by @dira/codegen â€” do not edit manually.

export interface TypedResponse<T> extends Response {
  json(): Promise<T>;
}

export interface ClientOptions {
  fetch?: typeof fetch;
}

export interface RouteMetadata {
  path: string;
  methods: string[];
}

interface RequestOptions<TBody = never, TQuery = never, TParams = never> {
  body?: TBody;
  query?: TQuery;
  params?: TParams;
  headers?: HeadersInit;
}

function request(
  fetchFn: typeof fetch,
  baseUrl: string,
  method: string,
  path: string,
  options?: RequestOptions<unknown, unknown, unknown>,
): Promise<TypedResponse<unknown>> {
  let url = path;
  if (options?.params) {
    for (const [key, value] of Object.entries(
      options.params as Record<string, string>,
    )) {
      // Handle wildcard params (::key) - encode each segment but preserve slashes
      if (url.includes('::' + key)) {
        const encoded = value
          .split('/')
          .map((s) => encodeURIComponent(s))
          .join('/');
        url = url.replace('::' + key, encoded);
      } else {
        // Handle regular params (:key)
        url = url.replace(`:${key}`, encodeURIComponent(value));
      }
    }
  }
  let fullUrl = baseUrl + url;
  if (options?.query) {
    const searchParams = new URLSearchParams();
    for (const [key, value] of Object.entries(
      options.query as Record<string, string | string[]>,
    )) {
      if (Array.isArray(value)) {
        for (const v of value) searchParams.append(key, v);
      } else if (value !== undefined) {
        searchParams.append(key, value);
      }
    }
    const qs = searchParams.toString();
    if (qs) fullUrl += '?' + qs;
  }
  const init: RequestInit = { method, headers: options?.headers };
  if (options?.body !== undefined) {
    init.body = JSON.stringify(options.body);
    init.headers = new Headers(init.headers);
    (init.headers as Headers).set('Content-Type', 'application/json');
  }
  return fetchFn(fullUrl, init) as Promise<TypedResponse<unknown>>;
}

const routes: Record<string, RouteMetadata> = {
  'health.check': {
    path: '/health/',
    methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],
  },
  'customers.list': { path: '/customers/list', methods: ['GET'] },
  'customers.get': { path: '/customers/:id', methods: ['GET'] },
  'customers.create': { path: '/customers/create', methods: ['POST'] },
  'customers.update': { path: '/customers/update/:id', methods: ['PUT'] },
  'customers.delete': { path: '/customers/delete/:id', methods: ['DELETE'] },
  'auth.login': { path: '/auth/login', methods: ['POST'] },
  'auth.me': {
    path: '/auth/me',
    methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],
  },
  'auth.logout': { path: '/auth/logout', methods: ['POST'] },
};

export interface FullAppClient {
  /** Route metadata for all endpoints */
  $routes: Record<string, RouteMetadata>;
  health: {
    check: {
      $route: RouteMetadata;
      $get(options?: {
        headers?: HeadersInit;
      }): Promise<TypedResponse<{ status: string; timestamp: string }>>;
      $post(options?: {
        headers?: HeadersInit;
      }): Promise<TypedResponse<{ status: string; timestamp: string }>>;
      $put(options?: {
        headers?: HeadersInit;
      }): Promise<TypedResponse<{ status: string; timestamp: string }>>;
      $patch(options?: {
        headers?: HeadersInit;
      }): Promise<TypedResponse<{ status: string; timestamp: string }>>;
      $delete(options?: {
        headers?: HeadersInit;
      }): Promise<TypedResponse<{ status: string; timestamp: string }>>;
    };
  };
  customers: {
    list: {
      $route: RouteMetadata;
      $get(options?: { headers?: HeadersInit }): Promise<
        TypedResponse<{
          customers: {
            id: string;
            name: string;
            email: string;
            createdAt: string;
          }[];
        }>
      >;
    };
    get: {
      $route: RouteMetadata;
      $get(options: {
        params: { id: string };
        headers?: HeadersInit;
      }): Promise<TypedResponse<Customer>>;
    };
    create: {
      $route: RouteMetadata;
      $post(options?: {
        headers?: HeadersInit;
      }): Promise<TypedResponse<Customer>>;
    };
    update: {
      $route: RouteMetadata;
      $put(options: {
        body: UpdateCustomerInput;
        params: { id: string };
        headers?: HeadersInit;
      }): Promise<TypedResponse<Customer>>;
    };
    delete: {
      $route: RouteMetadata;
      $delete(options: {
        params: { id: string };
        headers?: HeadersInit;
      }): Promise<TypedResponse<{ deleted: boolean; id: string }>>;
    };
  };
  auth: {
    login: {
      $route: RouteMetadata;
      $post(options?: {
        headers?: HeadersInit;
      }): Promise<TypedResponse<AuthToken>>;
    };
    me: {
      $route: RouteMetadata;
      $get(options?: { headers?: HeadersInit }): Promise<
        TypedResponse<{
          user: { id: string; name: string; role: 'admin' | 'user' };
        }>
      >;
      $post(options?: { headers?: HeadersInit }): Promise<
        TypedResponse<{
          user: { id: string; name: string; role: 'admin' | 'user' };
        }>
      >;
      $put(options?: { headers?: HeadersInit }): Promise<
        TypedResponse<{
          user: { id: string; name: string; role: 'admin' | 'user' };
        }>
      >;
      $patch(options?: { headers?: HeadersInit }): Promise<
        TypedResponse<{
          user: { id: string; name: string; role: 'admin' | 'user' };
        }>
      >;
      $delete(options?: { headers?: HeadersInit }): Promise<
        TypedResponse<{
          user: { id: string; name: string; role: 'admin' | 'user' };
        }>
      >;
    };
    logout: {
      $route: RouteMetadata;
      $post(options?: {
        headers?: HeadersInit;
      }): Promise<TypedResponse<{ success: boolean }>>;
    };
  };
}

export function createClient(
  baseUrl: string,
  options?: ClientOptions,
): FullAppClient {
  const fetchFn = options?.fetch ?? fetch;

  function createProxy(pathParts: string[]): unknown {
    return new Proxy(() => {}, {
      get(_, prop: string) {
        if (prop === '$routes') return routes;
        if (prop === '$route') return routes[pathParts.join('.')];
        if (prop.startsWith('$')) {
          const method = prop.slice(1).toUpperCase();
          const routeKey = pathParts.join('.');
          const route = routes[routeKey];
          if (!route) return undefined;
          return (opts?: unknown) =>
            request(fetchFn, baseUrl, method, route.path, opts as any);
        }
        return createProxy([...pathParts, prop]);
      },
    });
  }

  return createProxy([]) as FullAppClient;
}
